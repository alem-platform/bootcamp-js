# The Maze Escape

Once upon a time in the land of Computoria, there lived a valiant knight named Sir Wiggleton the Wanderer. Despite his brave reputation, Sir Wiggleton had a small problem: he couldn’t find his way out of anything, not even a simple hedge maze! Whether it was escaping from his castle or locating the royal outhouse, Wiggleton had a knack for getting stuck in the most trivial situations.

One day, Sir Wiggleton found himself lost inside a magical maze created by the mischievous wizard, Algor the Tricky. The maze was an ancient puzzle said to test the mental agility of even the most brilliant minds in Computoria. The wizard, however, found it amusing to keep Wiggleton trapped, watching him aimlessly wander about for hours.

But Wiggleton, not wanting to live out his days eating berries in a maze, cried out, “There must be a way out! And if I cannot find it, I’ll invent a strategy to get through!” Thus, Wiggleton began learning about two powerful techniques: [DFS](https://en.wikipedia.org/wiki/Depth-first_search) and [Dijkstra’s](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm) Pathfinding.

## Objective

You are given a maze in the form of a 2D array (grid) where:

- 1 represents the walls (border or obstacles that cannot be crossed),
- 0 represents open paths that can be navigated.

Your task is to find the shortest path from a starting point `X` to a target point `Y` using an algorithm of your choice. You must visualize the pathfinding process step-by-step as it dynamically explores the maze.

### Instructions

1. Input:

- A 2D array grid representing the maze.
- Coordinates start and end, where: - start = [x1, y1] is the starting position in the maze. - end = [x2, y2] is the destination point.

2. Output:

- A visualization of the maze exploration as the algorithm searches for the shortest path.
- The algorithm should highlight how it dynamically discovers new areas, moving towards the target.

3. Algorithm Choice:

- DFS (Depth-First Search): Will explore one path deeply before backtracking.
- Dijkstra's Algorithm: Will prioritize exploring shorter paths to the destination dynamically.

4. Visualization Requirements:

- Mark the cells that have been visited (during search process with selected Algorithm) with number 2.
- Highlight the final path once found by replacing cells with number 3
- For checking you solution you can use ready-for-use [starting code](https://github.com/alem-platform/bootcamp-js/tree/crunch01/crunch01/start)

### Testing

You can take those 3 starting maps for testing your solution:

```js
[
  [1, 1, 1, 1, 1, 1],
  [0, 0, 1, 0, 0, 1],
  [1, 0, 1, 1, 0, 1],
  [1, 0, 0, 0, 0, 1],
  [1, 1, 1, 1, 1, 1],
],
  [0, 1], // start point
  [3, 1]; // final destrination
```

```js
[
  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
  [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
  [1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1],
  [1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1],
  [1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1],
  [1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1],
  [1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1],
  [1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1],
  [1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1],
  [1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1],
  [1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
  [1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1],
  [1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1],
  [1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1],
  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
],
  [1, 1], // start point
  [16, 13]; // final destrination
```

```js
[
  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
  [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1],
  [1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1],
  [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1],
  [1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1],
  [1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1],
  [1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1],
  [1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1],
  [1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1],
  [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1],
  [1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1],
  [1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1],
  [1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1],
  [1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1],
  [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1],
  [1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1],
  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
],
  [1, 1], // start point
  [18, 15]; // final destrination
```
